name: Auto Build and Release

on:
  push:
    branches: [ main ]

permissions:
  contents: write

concurrency:
  group: auto-release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build PDF from LaTeX
        uses: xu-cheng/latex-action@v2
        with:
          root_file: resume.tex

      - name: Create release tag and release
        id: create_release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Get the latest commit message from this push
            const headCommit = context.payload.head_commit;
            const fullMsg = headCommit ? headCommit.message || "" : "";
            const title = (fullMsg.split("\n")[0] || "").trim() || "New release";

            // Fetch all releases and find the highest v0.0.x tag
            const releases = await github.paginate(github.rest.repos.listReleases, {
              owner, repo, per_page: 100
            });

            const tagNums = releases
              .map(r => r.tag_name)
              .map(t => {
                const m = /^v0\.0\.(\d+)$/.exec(t || "");
                return m ? parseInt(m[1], 10) : null;
              })
              .filter(n => Number.isInteger(n));

            const nextNum = (tagNums.length ? Math.max(...tagNums) : 0) + 1;
            const nextTag = `v0.0.${nextNum}`;

            // Create a lightweight tag pointing to the current commit SHA
            const sha = context.sha;

            // Ensure tag doesn't already exist (handle race conditions)
            async function ensureTag(baseTag, attempt = 0) {
              const candidate = attempt === 0 ? baseTag : `v0.0.${nextNum + attempt}`;
              try {
                // Check if ref exists
                await github.rest.git.getRef({ owner, repo, ref: `tags/${candidate}` });
                // If it exists, try the next one
                return ensureTag(baseTag, attempt + 1);
              } catch (e) {
                // 404 means it doesn't exist; create it
                if (e.status === 404) {
                  await github.rest.git.createRef({
                    owner, repo,
                    ref: `refs/tags/${candidate}`,
                    sha
                  });
                  return candidate;
                }
                throw e;
              }
            }

            const finalTag = await ensureTag(nextTag);

            // Create the release with the title from the commit message
            const release = await github.rest.repos.createRelease({
              owner, repo,
              tag_name: finalTag,
              name: title,
              generate_release_notes: true,
              draft: false
            });

            core.info(`Created release ${release.data.html_url} with tag ${finalTag} and title "${title}"`);
            
            return {
              upload_url: release.data.upload_url,
              tag_name: finalTag
            };

      - name: Upload PDF to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ fromJson(steps.create_release.outputs.result).upload_url }}
          asset_path: resume.pdf
          asset_name: ${{ github.actor }}_resume.pdf
          asset_content_type: application/pdf
